"""
数据库模型生成器 Skill
======================
自动生成SQLAlchemy/Peewee数据库模型代码
"""

from pathlib import Path
from typing import List, Dict, Optional
from datetime import datetime


class DatabaseModelGenerator:
    """数据库模型生成器"""

    def __init__(self, output_dir: str = ".", orm: str = "sqlalchemy"):
        self.output_dir = Path(output_dir)
        self.orm = orm.lower()

    def generate(
        self,
        entity_name: str,
        fields: List[Dict],
        relationships: Optional[List[Dict]] = None,
        indexes: Optional[List[str]] = None
    ) -> Dict[str, str]:
        """
        生成数据库模型代码

        Args:
            entity_name: 实体名称
            fields: 字段定义列表
            relationships: 关系定义
            indexes: 索引定义

        Returns:
            生成的代码字典
        """
        relationships = relationships or []
        indexes = indexes or []

        results = {}

        if self.orm == "sqlalchemy":
            results['model'] = self._generate_sqlalchemy_model(entity_name, fields, relationships, indexes)
            results['migration'] = self._generate_alembic_migration(entity_name, fields, indexes)
        else:
            results['model'] = self._generate_peewee_model(entity_name, fields, relationships)

        return results

    def _generate_sqlalchemy_model(
        self,
        entity_name: str,
        fields: List[Dict],
        relationships: List[Dict],
        indexes: List[str]
    ) -> str:
        """生成SQLAlchemy模型"""
        class_name = entity_name.capitalize()
        table_name = entity_name.lower() + 's'

        # 生成字段
        field_lines = []
        for field in fields:
            line = self._generate_sqlalchemy_field(field)
            field_lines.append(line)

        # 生成关系
        rel_lines = []
        for rel in relationships:
            line = self._generate_sqlalchemy_relationship(rel, class_name)
            rel_lines.append(line)

        # 生成索引
        index_lines = []
        for idx in indexes:
            index_lines.append(f"    db.Index('ix_{table_name}_{idx}', '{idx}'),")

        fields_str = "\n".join(field_lines)
        rels_str = "\n".join(rel_lines) if rel_lines else ""
        indexes_str = "\n".join(index_lines) if index_lines else ""

        # 生成to_dict方法的字段
        to_dict_fields = self._generate_to_dict(fields)

        return f'''"""
{class_name} Model
==================
Generated by Leo Database Model Generator
"""
from datetime import datetime
from app import db


class {class_name}(db.Model):
    """
    {class_name}数据模型

    Attributes:
        id: 主键ID
{self._generate_docstring_fields(fields)}
        created_at: 创建时间
        updated_at: 更新时间
    """
    __tablename__ = '{table_name}'

    # 主键
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)

    # 字段
{fields_str}

    # 时间戳
    created_at = db.Column(db.DateTime, default=datetime.utcnow, nullable=False)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)

{rels_str}
    # 索引
    __table_args__ = (
{indexes_str}
    )

    def to_dict(self) -> dict:
        """转换为字典"""
        return {{
            'id': self.id,
{to_dict_fields}
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None
        }}

    @classmethod
    def from_dict(cls, data: dict) -> '{class_name}':
        """从字典创建实例"""
        return cls(**{{k: v for k, v in data.items() if hasattr(cls, k)}})

    def update_from_dict(self, data: dict) -> None:
        """从字典更新实例"""
        for key, value in data.items():
            if hasattr(self, key) and key not in ('id', 'created_at', 'updated_at'):
                setattr(self, key, value)

    def __repr__(self) -> str:
        return f'<{class_name} {{self.id}}>'
'''

    def _generate_sqlalchemy_field(self, field: Dict) -> str:
        """生成SQLAlchemy字段定义"""
        name = field['name']
        ftype = field.get('type', 'string')
        required = field.get('required', False)
        unique = field.get('unique', False)
        default = field.get('default')
        max_length = field.get('max_length', 255)
        foreign_key = field.get('foreign_key')

        # 类型映射
        type_map = {
            'string': f'db.String({max_length})',
            'text': 'db.Text',
            'integer': 'db.Integer',
            'float': 'db.Float',
            'boolean': 'db.Boolean',
            'datetime': 'db.DateTime',
            'date': 'db.Date',
            'json': 'db.JSON',
            'enum': f"db.Enum({', '.join(repr(v) for v in field.get('values', []))})"
        }

        col_type = type_map.get(ftype, 'db.String(255)')

        # 构建列定义
        parts = [f"db.Column({col_type}"]

        if foreign_key:
            parts.append(f", db.ForeignKey('{foreign_key}')")

        if unique:
            parts.append(", unique=True")

        if not required:
            parts.append(", nullable=True")
        else:
            parts.append(", nullable=False")

        if default is not None:
            if isinstance(default, str):
                parts.append(f", default='{default}'")
            elif isinstance(default, bool):
                parts.append(f", default={default}")
            else:
                parts.append(f", default={default}")

        parts.append(")")

        return f"    {name} = {''.join(parts)}"

    def _generate_sqlalchemy_relationship(self, rel: Dict, class_name: str) -> str:
        """生成SQLAlchemy关系定义"""
        name = rel['name']
        rel_type = rel.get('type', 'one_to_many')
        target = rel.get('target', class_name)
        back_ref = rel.get('back_ref', name)

        if rel_type == 'self_referential':
            return f"    {name} = db.relationship('{class_name}', backref=db.backref('{back_ref}', remote_side=[id]))"
        elif rel_type == 'one_to_many':
            return f"    {name} = db.relationship('{target}', backref='{back_ref}', lazy='dynamic')"
        elif rel_type == 'many_to_many':
            return f"    {name} = db.relationship('{target}', secondary='{name}_association', backref='{back_ref}')"
        else:
            return f"    # {name}: {rel_type} relationship"

    def _generate_alembic_migration(
        self,
        entity_name: str,
        fields: List[Dict],
        indexes: List[str]
    ) -> str:
        """生成Alembic迁移脚本"""
        table_name = entity_name.lower() + 's'
        timestamp = datetime.now().strftime('%Y%m%d%H%M%S')

        # 生成列定义
        col_lines = []
        for field in fields:
            col_lines.append(self._generate_migration_column(field))

        cols_str = ",\n        ".join(col_lines)

        # 生成索引
        idx_lines = []
        for idx in indexes:
            idx_lines.append(f"    op.create_index('ix_{table_name}_{idx}', '{table_name}', ['{idx}'])")

        idx_str = "\n".join(idx_lines) if idx_lines else "    pass"

        return f'''"""
Create {entity_name} table

Revision ID: {timestamp}
Create Date: {datetime.now().isoformat()}
"""
from alembic import op
import sqlalchemy as sa

revision = '{timestamp}'
down_revision = None
branch_labels = None
depends_on = None


def upgrade():
    op.create_table(
        '{table_name}',
        sa.Column('id', sa.Integer(), primary_key=True, autoincrement=True),
        {cols_str},
        sa.Column('created_at', sa.DateTime(), nullable=False),
        sa.Column('updated_at', sa.DateTime(), nullable=False)
    )

    # 创建索引
{idx_str}


def downgrade():
    op.drop_table('{table_name}')
'''

    def _generate_migration_column(self, field: Dict) -> str:
        """生成迁移脚本的列定义"""
        name = field['name']
        ftype = field.get('type', 'string')
        required = field.get('required', False)
        max_length = field.get('max_length', 255)

        type_map = {
            'string': f'sa.String({max_length})',
            'text': 'sa.Text()',
            'integer': 'sa.Integer()',
            'float': 'sa.Float()',
            'boolean': 'sa.Boolean()',
            'datetime': 'sa.DateTime()',
            'json': 'sa.JSON()'
        }

        col_type = type_map.get(ftype, 'sa.String(255)')
        nullable = 'False' if required else 'True'

        return f"sa.Column('{name}', {col_type}, nullable={nullable})"

    def _generate_peewee_model(
        self,
        entity_name: str,
        fields: List[Dict],
        relationships: List[Dict]
    ) -> str:
        """生成Peewee模型"""
        class_name = entity_name.capitalize()

        field_lines = []
        for field in fields:
            line = self._generate_peewee_field(field)
            field_lines.append(line)

        fields_str = "\n".join(field_lines)

        return f'''"""
{class_name} Model (Peewee)
"""
from datetime import datetime
from peewee import *
from app import db


class {class_name}(Model):
    """
    {class_name}数据模型
    """
{fields_str}
    created_at = DateTimeField(default=datetime.now)
    updated_at = DateTimeField(default=datetime.now)

    class Meta:
        database = db
        table_name = '{entity_name.lower()}s'

    def save(self, *args, **kwargs):
        self.updated_at = datetime.now()
        return super().save(*args, **kwargs)
'''

    def _generate_peewee_field(self, field: Dict) -> str:
        """生成Peewee字段定义"""
        name = field['name']
        ftype = field.get('type', 'string')
        required = field.get('required', False)
        default = field.get('default')
        max_length = field.get('max_length', 255)

        type_map = {
            'string': f'CharField(max_length={max_length}',
            'text': 'TextField(',
            'integer': 'IntegerField(',
            'float': 'FloatField(',
            'boolean': 'BooleanField(',
            'datetime': 'DateTimeField(',
            'json': 'JSONField('
        }

        field_type = type_map.get(ftype, 'CharField(')

        parts = [f"    {name} = {field_type}"]

        if not required:
            parts.append("null=True")

        if default is not None:
            if isinstance(default, str):
                parts.append(f"default='{default}'")
            else:
                parts.append(f"default={default}")

        return ", ".join(parts) + ")"

    def _generate_to_dict(self, fields: List[Dict]) -> str:
        """生成to_dict方法的字段"""
        lines = []
        for field in fields:
            name = field['name']
            ftype = field.get('type', 'string')
            if ftype == 'datetime':
                lines.append(f"            '{name}': self.{name}.isoformat() if self.{name} else None,")
            else:
                lines.append(f"            '{name}': self.{name},")
        return "\n".join(lines)

    def _generate_docstring_fields(self, fields: List[Dict]) -> str:
        """生成文档字符串的字段说明"""
        lines = []
        for field in fields:
            name = field['name']
            ftype = field.get('type', 'string')
            desc = field.get('description', name)
            lines.append(f"        {name}: {desc} ({ftype})")
        return "\n".join(lines)

    def save_files(self, entity_name: str, results: Dict[str, str]) -> Dict[str, Path]:
        """保存生成的文件"""
        saved = {}

        # 保存模型
        models_dir = self.output_dir / 'app' / 'models'
        models_dir.mkdir(parents=True, exist_ok=True)
        model_path = models_dir / f'{entity_name.lower()}.py'
        model_path.write_text(results['model'], encoding='utf-8')
        saved['model'] = model_path

        # 保存迁移脚本
        if 'migration' in results:
            migrations_dir = self.output_dir / 'migrations' / 'versions'
            migrations_dir.mkdir(parents=True, exist_ok=True)
            timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
            migration_path = migrations_dir / f'{timestamp}_create_{entity_name.lower()}.py'
            migration_path.write_text(results['migration'], encoding='utf-8')
            saved['migration'] = migration_path

        return saved


def main():
    """示例用法"""
    generator = DatabaseModelGenerator(output_dir="./output", orm="sqlalchemy")

    fields = [
        {'name': 'name', 'type': 'string', 'required': True, 'max_length': 100},
        {'name': 'phone', 'type': 'string', 'required': True, 'max_length': 20},
        {'name': 'parent_id', 'type': 'integer', 'foreign_key': 'leads.id'},
        {'name': 'status', 'type': 'string', 'default': 'new'},
        {'name': 'depth', 'type': 'integer', 'default': 0}
    ]

    relationships = [
        {'name': 'parent', 'type': 'self_referential', 'back_ref': 'children'}
    ]

    results = generator.generate(
        entity_name='Lead',
        fields=fields,
        relationships=relationships,
        indexes=['status', 'phone']
    )

    saved = generator.save_files('Lead', results)
    print("生成完成！")
    for name, path in saved.items():
        print(f"  {name}: {path}")


if __name__ == '__main__':
    main()
