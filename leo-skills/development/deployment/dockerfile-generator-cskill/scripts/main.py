"""
Dockerfile 生成器 Skill
=======================
自动生成优化的Dockerfile和docker-compose配置
"""

from pathlib import Path
from typing import List, Dict, Optional


class DockerfileGenerator:
    """Dockerfile生成器"""

    # 应用类型配置
    APP_CONFIGS = {
        'flask': {
            'base_image': 'python:3.9-slim',
            'port': 5000,
            'install_cmd': 'pip install --no-cache-dir -r requirements.txt',
            'run_cmd': 'gunicorn -w 4 -b 0.0.0.0:5000 app:app'
        },
        'fastapi': {
            'base_image': 'python:3.9-slim',
            'port': 8000,
            'install_cmd': 'pip install --no-cache-dir -r requirements.txt',
            'run_cmd': 'uvicorn app.main:app --host 0.0.0.0 --port 8000'
        },
        'node': {
            'base_image': 'node:18-alpine',
            'port': 3000,
            'install_cmd': 'npm ci --only=production',
            'run_cmd': 'node server.js'
        },
        'vue': {
            'base_image': 'node:18-alpine',
            'build_image': 'nginx:alpine',
            'port': 80,
            'install_cmd': 'npm ci',
            'build_cmd': 'npm run build'
        },
        'react': {
            'base_image': 'node:18-alpine',
            'build_image': 'nginx:alpine',
            'port': 80,
            'install_cmd': 'npm ci',
            'build_cmd': 'npm run build'
        }
    }

    def __init__(self, output_dir: str = "."):
        self.output_dir = Path(output_dir)

    def generate(
        self,
        app_type: str,
        runtime: Optional[str] = None,
        port: Optional[int] = None,
        multi_stage: bool = True,
        with_compose: bool = True,
        services: Optional[List[str]] = None
    ) -> Dict[str, str]:
        """
        生成Docker配置文件

        Args:
            app_type: 应用类型
            runtime: 运行时版本
            port: 暴露端口
            multi_stage: 是否多阶段构建
            with_compose: 是否生成docker-compose
            services: 额外服务列表

        Returns:
            生成的配置文件字典
        """
        services = services or []
        config = self.APP_CONFIGS.get(app_type, self.APP_CONFIGS['flask'])

        if runtime:
            config['base_image'] = runtime
        if port:
            config['port'] = port

        results = {}

        # 生成Dockerfile
        if app_type in ['vue', 'react'] and multi_stage:
            results['dockerfile'] = self._generate_frontend_dockerfile(app_type, config)
        elif app_type in ['flask', 'fastapi']:
            results['dockerfile'] = self._generate_python_dockerfile(app_type, config, multi_stage)
        else:
            results['dockerfile'] = self._generate_node_dockerfile(config)

        # 生成.dockerignore
        results['dockerignore'] = self._generate_dockerignore(app_type)

        # 生成docker-compose
        if with_compose:
            results['compose'] = self._generate_docker_compose(app_type, config, services)
            results['compose_prod'] = self._generate_docker_compose_prod(app_type, config, services)

        return results

    def _generate_python_dockerfile(self, app_type: str, config: Dict, multi_stage: bool) -> str:
        """生成Python应用Dockerfile"""
        base_image = config['base_image']
        port = config['port']
        run_cmd = config['run_cmd']

        if multi_stage:
            return f'''# ==========================================
# Dockerfile for {app_type.upper()} Application
# Generated by Leo Dockerfile Generator
# ==========================================

# Stage 1: Builder
FROM {base_image} AS builder

WORKDIR /app

# 安装构建依赖
RUN apt-get update && apt-get install -y --no-install-recommends \\
    gcc \\
    && rm -rf /var/lib/apt/lists/*

# 复制依赖文件
COPY requirements.txt .

# 安装Python依赖
RUN pip install --no-cache-dir --user -r requirements.txt

# Stage 2: Runtime
FROM {base_image}

WORKDIR /app

# 创建非root用户
RUN useradd --create-home --shell /bin/bash appuser

# 从builder阶段复制依赖
COPY --from=builder /root/.local /home/appuser/.local

# 复制应用代码
COPY --chown=appuser:appuser . .

# 设置环境变量
ENV PATH=/home/appuser/.local/bin:$PATH
ENV PYTHONUNBUFFERED=1
ENV FLASK_ENV=production

# 切换到非root用户
USER appuser

# 暴露端口
EXPOSE {port}

# 健康检查
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\
    CMD curl -f http://localhost:{port}/health || exit 1

# 启动命令
CMD ["{run_cmd.split()[0]}", "{run_cmd.split()[1] if len(run_cmd.split()) > 1 else ''}", \\
     "{run_cmd.split()[2] if len(run_cmd.split()) > 2 else ''}", \\
     "{run_cmd.split()[3] if len(run_cmd.split()) > 3 else ''}", \\
     "{run_cmd.split()[4] if len(run_cmd.split()) > 4 else ''}"]
'''
        else:
            return f'''# Dockerfile for {app_type.upper()} Application
FROM {base_image}

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE {port}

CMD {run_cmd.split()}
'''

    def _generate_frontend_dockerfile(self, app_type: str, config: Dict) -> str:
        """生成前端应用Dockerfile（多阶段构建）"""
        base_image = config['base_image']
        build_image = config.get('build_image', 'nginx:alpine')
        port = config['port']

        return f'''# ==========================================
# Dockerfile for {app_type.upper()} Application
# Multi-stage build with Nginx
# Generated by Leo Dockerfile Generator
# ==========================================

# Stage 1: Build
FROM {base_image} AS builder

WORKDIR /app

# 复制package文件
COPY package*.json ./

# 安装依赖
RUN npm ci

# 复制源代码
COPY . .

# 构建应用
RUN npm run build

# Stage 2: Production
FROM {build_image}

# 复制nginx配置
COPY nginx.conf /etc/nginx/conf.d/default.conf

# 从builder阶段复制构建产物
COPY --from=builder /app/dist /usr/share/nginx/html

# 暴露端口
EXPOSE {port}

# 健康检查
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\
    CMD curl -f http://localhost:{port}/ || exit 1

# 启动nginx
CMD ["nginx", "-g", "daemon off;"]
'''

    def _generate_node_dockerfile(self, config: Dict) -> str:
        """生成Node.js应用Dockerfile"""
        base_image = config['base_image']
        port = config['port']

        return f'''# Dockerfile for Node.js Application
FROM {base_image}

WORKDIR /app

# 创建非root用户
RUN addgroup -g 1001 -S nodejs && adduser -S nodejs -u 1001

# 复制package文件
COPY package*.json ./

# 安装依赖
RUN npm ci --only=production

# 复制源代码
COPY --chown=nodejs:nodejs . .

USER nodejs

EXPOSE {port}

HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\
    CMD curl -f http://localhost:{port}/health || exit 1

CMD ["node", "server.js"]
'''

    def _generate_dockerignore(self, app_type: str) -> str:
        """生成.dockerignore文件"""
        common = '''# Git
.git
.gitignore

# IDE
.idea
.vscode
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Logs
*.log
logs/

# Docker
Dockerfile*
docker-compose*
.docker

# Documentation
README.md
docs/
'''

        if app_type in ['flask', 'fastapi']:
            return common + '''
# Python
__pycache__/
*.py[cod]
*$py.class
.Python
venv/
.venv/
env/
.env
*.egg-info/
.pytest_cache/
.coverage
htmlcov/
'''
        else:
            return common + '''
# Node
node_modules/
npm-debug.log
yarn-error.log
.npm
.yarn

# Build
dist/
build/
.next/
.nuxt/

# Environment
.env
.env.local
.env.*.local
'''

    def _generate_docker_compose(
        self,
        app_type: str,
        config: Dict,
        services: List[str]
    ) -> str:
        """生成docker-compose.yml"""
        port = config['port']

        compose = f'''# docker-compose.yml
# Development environment
# Generated by Leo Dockerfile Generator

version: '3.8'

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "{port}:{port}"
    volumes:
      - .:/app
      - /app/node_modules  # 仅Node.js应用需要
    environment:
      - NODE_ENV=development
      - FLASK_ENV=development
      - DATABASE_URL=mysql://root:password@db:3306/app
      - REDIS_URL=redis://cache:6379/0
    depends_on:
      - db
      - cache
    restart: unless-stopped
'''

        if 'mysql' in services or 'db' in services:
            compose += '''
  db:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: password
      MYSQL_DATABASE: app
    ports:
      - "3306:3306"
    volumes:
      - mysql_data:/var/lib/mysql
    restart: unless-stopped
'''

        if 'redis' in services or 'cache' in services:
            compose += '''
  cache:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    restart: unless-stopped
'''

        if 'nginx' in services or 'proxy' in services:
            compose += '''
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/conf.d/default.conf
    depends_on:
      - app
    restart: unless-stopped
'''

        compose += '''
volumes:
  mysql_data:
  redis_data:

networks:
  default:
    name: app_network
'''

        return compose

    def _generate_docker_compose_prod(
        self,
        app_type: str,
        config: Dict,
        services: List[str]
    ) -> str:
        """生成生产环境docker-compose配置"""
        port = config['port']

        return f'''# docker-compose.prod.yml
# Production environment
# Usage: docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d

version: '3.8'

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
      target: production  # 如果使用多阶段构建
    environment:
      - NODE_ENV=production
      - FLASK_ENV=production
    deploy:
      replicas: 2
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
        reservations:
          cpus: '0.25'
          memory: 256M
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  db:
    environment:
      MYSQL_ROOT_PASSWORD_FILE: /run/secrets/db_password
    secrets:
      - db_password
    deploy:
      resources:
        limits:
          memory: 1G

  cache:
    deploy:
      resources:
        limits:
          memory: 256M

secrets:
  db_password:
    file: ./secrets/db_password.txt
'''

    def save_files(self, results: Dict[str, str]) -> Dict[str, Path]:
        """保存生成的文件"""
        saved = {}

        self.output_dir.mkdir(parents=True, exist_ok=True)

        file_mapping = {
            'dockerfile': 'Dockerfile',
            'dockerignore': '.dockerignore',
            'compose': 'docker-compose.yml',
            'compose_prod': 'docker-compose.prod.yml'
        }

        for key, filename in file_mapping.items():
            if key in results:
                file_path = self.output_dir / filename
                file_path.write_text(results[key], encoding='utf-8')
                saved[key] = file_path

        return saved


def main():
    """示例用法"""
    generator = DockerfileGenerator(output_dir="./output")

    # 生成Flask应用的Docker配置
    results = generator.generate(
        app_type='flask',
        runtime='python:3.9-slim',
        port=5000,
        multi_stage=True,
        with_compose=True,
        services=['mysql', 'redis', 'nginx']
    )

    saved = generator.save_files(results)
    print("生成完成！")
    for name, path in saved.items():
        print(f"  {name}: {path}")


if __name__ == '__main__':
    main()
