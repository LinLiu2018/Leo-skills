"""
Vue3组件生成器 Skill
====================
生成Vue3组件（Composition API + TypeScript）
"""

from pathlib import Path
from typing import List, Dict, Optional


class VueComponentGenerator:
    """Vue3组件生成器"""

    def __init__(self, output_dir: str = ".", typescript: bool = True):
        self.output_dir = Path(output_dir)
        self.typescript = typescript

    def generate(
        self,
        component_name: str,
        props: Optional[List[Dict]] = None,
        emits: Optional[List[str]] = None,
        slots: Optional[List[str]] = None,
        features: Optional[List[str]] = None
    ) -> Dict[str, str]:
        """
        生成Vue3组件

        Args:
            component_name: 组件名称（PascalCase）
            props: 属性定义列表
            emits: 事件列表
            slots: 插槽列表
            features: 特性列表（如loading, pagination等）

        Returns:
            生成的代码字典
        """
        props = props or []
        emits = emits or []
        slots = slots or []
        features = features or []

        results = {}

        # 生成Vue组件
        results['vue'] = self._generate_vue_component(
            component_name, props, emits, slots, features
        )

        # 生成TypeScript类型定义
        if self.typescript:
            results['types'] = self._generate_types(component_name, props, emits)

        # 生成单元测试
        results['test'] = self._generate_test(component_name, props)

        return results

    def _generate_vue_component(
        self,
        name: str,
        props: List[Dict],
        emits: List[str],
        slots: List[str],
        features: List[str]
    ) -> str:
        """生成Vue3组件代码"""

        # Props定义
        props_def = self._generate_props_definition(props)

        # Emits定义
        emits_def = f"const emit = defineEmits<{{{self._generate_emits_types(emits)}}}>()" if emits else ""

        # 模板
        template = self._generate_template(name, props, slots, features)

        # 样式
        style = self._generate_style(name, features)

        # 脚本
        script_content = self._generate_script_content(name, props, emits, features)

        ext = "ts" if self.typescript else "js"

        return f'''<template>
{template}
</template>

<script setup lang="{ext}">
/**
 * {name} 组件
 * Generated by Leo Vue Component Generator
 */
{script_content}
</script>

<style scoped lang="scss">
{style}
</style>
'''

    def _generate_props_definition(self, props: List[Dict]) -> str:
        """生成Props定义"""
        if not props:
            return ""

        lines = []
        for prop in props:
            name = prop['name']
            ptype = prop.get('type', 'string')
            required = prop.get('required', False)
            default = prop.get('default')

            ts_type = self._map_ts_type(ptype)

            if default is not None:
                if isinstance(default, str):
                    lines.append(f"  {name}?: {ts_type}")
                else:
                    lines.append(f"  {name}?: {ts_type}")
            elif required:
                lines.append(f"  {name}: {ts_type}")
            else:
                lines.append(f"  {name}?: {ts_type}")

        return "interface Props {\n" + "\n".join(lines) + "\n}\n\nconst props = defineProps<Props>()"

    def _generate_emits_types(self, emits: List[str]) -> str:
        """生成Emits类型"""
        lines = []
        for emit in emits:
            lines.append(f"  (e: '{emit}', value: any): void")
        return "\n".join(lines)

    def _generate_template(
        self,
        name: str,
        props: List[Dict],
        slots: List[str],
        features: List[str]
    ) -> str:
        """生成模板"""
        kebab_name = self._to_kebab_case(name)

        # 基础容器
        content = f'  <div class="{kebab_name}">'

        # Loading状态
        if 'loading' in features:
            content += '''
    <div v-if="loading" class="loading-wrapper">
      <span class="loading-spinner"></span>
    </div>
    <template v-else>'''

        # 插槽
        if slots:
            for slot in slots:
                if slot == 'default':
                    content += '\n      <slot></slot>'
                else:
                    content += f'\n      <slot name="{slot}"></slot>'
        else:
            content += '\n      <!-- 组件内容 -->'

        if 'loading' in features:
            content += '\n    </template>'

        content += '\n  </div>'

        return content

    def _generate_style(self, name: str, features: List[str]) -> str:
        """生成样式"""
        kebab_name = self._to_kebab_case(name)

        style = f'''.{kebab_name} {{
  position: relative;
}}'''

        if 'loading' in features:
            style += '''

.loading-wrapper {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100px;
}

.loading-spinner {
  width: 24px;
  height: 24px;
  border: 2px solid #f3f3f3;
  border-top: 2px solid #3498db;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}'''

        return style

    def _generate_script_content(
        self,
        name: str,
        props: List[Dict],
        emits: List[str],
        features: List[str]
    ) -> str:
        """生成脚本内容"""
        lines = []

        # 导入
        imports = ["ref"]
        if 'computed' in features:
            imports.append("computed")
        if 'watch' in features:
            imports.append("watch")
        if 'lifecycle' in features:
            imports.extend(["onMounted", "onUnmounted"])

        lines.append(f"import {{ {', '.join(imports)} }} from 'vue'")
        lines.append("")

        # Props
        if props:
            lines.append(self._generate_props_definition(props))
            lines.append("")

        # Emits
        if emits:
            lines.append(f"const emit = defineEmits<{{{self._generate_emits_types(emits)}}}>()")
            lines.append("")

        # 响应式状态
        if 'loading' in features:
            lines.append("const loading = ref(false)")

        # 生命周期
        if 'lifecycle' in features:
            lines.append("""
onMounted(() => {
  // 组件挂载后执行
})

onUnmounted(() => {
  // 组件卸载前执行
})""")

        return "\n".join(lines)

    def _generate_types(self, name: str, props: List[Dict], emits: List[str]) -> str:
        """生成TypeScript类型定义"""
        lines = [f"// {name} 类型定义", ""]

        # Props接口
        if props:
            lines.append(f"export interface {name}Props {{")
            for prop in props:
                pname = prop['name']
                ptype = self._map_ts_type(prop.get('type', 'string'))
                required = prop.get('required', False)
                optional = "" if required else "?"
                lines.append(f"  {pname}{optional}: {ptype}")
            lines.append("}")
            lines.append("")

        # Emits接口
        if emits:
            lines.append(f"export interface {name}Emits {{")
            for emit in emits:
                lines.append(f"  (e: '{emit}', value: any): void")
            lines.append("}")

        return "\n".join(lines)

    def _generate_test(self, name: str, props: List[Dict]) -> str:
        """生成单元测试"""
        kebab_name = self._to_kebab_case(name)

        # 生成props mock
        props_mock = "{"
        for prop in props:
            pname = prop['name']
            ptype = prop.get('type', 'string')
            if ptype == 'string':
                props_mock += f"\n      {pname}: 'test',"
            elif ptype == 'number':
                props_mock += f"\n      {pname}: 1,"
            elif ptype == 'boolean':
                props_mock += f"\n      {pname}: true,"
            elif ptype == 'array':
                props_mock += f"\n      {pname}: [],"
            else:
                props_mock += f"\n      {pname}: {{}},"
        props_mock += "\n    }" if props else "{}"

        return f'''import {{ describe, it, expect }} from 'vitest'
import {{ mount }} from '@vue/test-utils'
import {name} from './{name}.vue'

describe('{name}', () => {{
  it('renders properly', () => {{
    const wrapper = mount({name}, {{
      props: {props_mock}
    }})
    expect(wrapper.exists()).toBe(true)
  }})

  it('has correct class name', () => {{
    const wrapper = mount({name})
    expect(wrapper.classes()).toContain('{kebab_name}')
  }})
}})
'''

    def _map_ts_type(self, ptype: str) -> str:
        """映射TypeScript类型"""
        type_map = {
            'string': 'string',
            'number': 'number',
            'boolean': 'boolean',
            'array': 'any[]',
            'object': 'Record<string, any>',
            'function': '(...args: any[]) => any',
            'date': 'Date'
        }
        return type_map.get(ptype.lower(), 'any')

    def _to_kebab_case(self, name: str) -> str:
        """转换为kebab-case"""
        import re
        s1 = re.sub('(.)([A-Z][a-z]+)', r'\1-\2', name)
        return re.sub('([a-z0-9])([A-Z])', r'\1-\2', s1).lower()

    def save_files(self, component_name: str, results: Dict[str, str]) -> Dict[str, Path]:
        """保存生成的文件"""
        saved = {}
        comp_dir = self.output_dir / 'components' / component_name
        comp_dir.mkdir(parents=True, exist_ok=True)

        # Vue组件
        vue_path = comp_dir / f'{component_name}.vue'
        vue_path.write_text(results['vue'], encoding='utf-8')
        saved['vue'] = vue_path

        # 类型定义
        if 'types' in results:
            types_path = comp_dir / f'{component_name}.types.ts'
            types_path.write_text(results['types'], encoding='utf-8')
            saved['types'] = types_path

        # 测试文件
        test_path = comp_dir / f'{component_name}.spec.ts'
        test_path.write_text(results['test'], encoding='utf-8')
        saved['test'] = test_path

        # 导出文件
        index_content = f"export {{ default as {component_name} }} from './{component_name}.vue'\n"
        if 'types' in results:
            index_content += f"export * from './{component_name}.types'\n"
        index_path = comp_dir / 'index.ts'
        index_path.write_text(index_content, encoding='utf-8')
        saved['index'] = index_path

        return saved


def main():
    """示例用法"""
    generator = VueComponentGenerator(output_dir="./output", typescript=True)

    # 生成一个数据表格组件
    results = generator.generate(
        component_name='DataTable',
        props=[
            {'name': 'data', 'type': 'array', 'required': True},
            {'name': 'columns', 'type': 'array', 'required': True},
            {'name': 'loading', 'type': 'boolean', 'default': False},
            {'name': 'pagination', 'type': 'boolean', 'default': True}
        ],
        emits=['row-click', 'page-change'],
        slots=['default', 'header', 'footer'],
        features=['loading', 'lifecycle']
    )

    saved = generator.save_files('DataTable', results)
    print("生成完成！")
    for name, path in saved.items():
        print(f"  {name}: {path}")


if __name__ == '__main__':
    main()
