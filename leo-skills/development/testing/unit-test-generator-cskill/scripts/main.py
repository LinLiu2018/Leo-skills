"""
单元测试生成器 Skill
====================
自动生成Python/JavaScript单元测试代码
"""

from pathlib import Path
from typing import Dict, Optional, List
import re


class UnitTestGenerator:
    """单元测试生成器"""

    def __init__(self, output_dir: str = ".", language: str = "python"):
        self.output_dir = Path(output_dir)
        self.language = language.lower()

    def generate(
        self,
        source_code: str,
        test_framework: Optional[str] = None,
        coverage_target: int = 80
    ) -> Dict[str, str]:
        """
        生成单元测试

        Args:
            source_code: 源代码
            test_framework: 测试框架
            coverage_target: 覆盖率目标

        Returns:
            生成的测试代码字典
        """
        if self.language == 'python':
            framework = test_framework or 'pytest'
            return self._generate_python_tests(source_code, framework)
        elif self.language in ['javascript', 'typescript', 'js', 'ts']:
            framework = test_framework or 'vitest'
            return self._generate_js_tests(source_code, framework)
        else:
            return {'error': f'Unsupported language: {self.language}'}

    def _generate_python_tests(self, source_code: str, framework: str) -> Dict[str, str]:
        """生成Python测试"""
        # 解析源代码
        functions = self._extract_python_functions(source_code)
        classes = self._extract_python_classes(source_code)

        results = {}

        if framework == 'pytest':
            results['test'] = self._generate_pytest(functions, classes)
        else:
            results['test'] = self._generate_unittest(functions, classes)

        results['conftest'] = self._generate_conftest()

        return results

    def _extract_python_functions(self, code: str) -> List[Dict]:
        """提取Python函数"""
        pattern = r'def\s+(\w+)\s*\((.*?)\)(?:\s*->\s*(\w+))?:'
        matches = re.findall(pattern, code)

        functions = []
        for match in matches:
            name, params, return_type = match
            if not name.startswith('_'):  # 跳过私有方法
                functions.append({
                    'name': name,
                    'params': [p.strip().split(':')[0].strip() for p in params.split(',') if p.strip()],
                    'return_type': return_type or 'None'
                })

        return functions

    def _extract_python_classes(self, code: str) -> List[Dict]:
        """提取Python类"""
        class_pattern = r'class\s+(\w+)(?:\(.*?\))?:'
        matches = re.findall(class_pattern, code)

        classes = []
        for class_name in matches:
            # 提取类方法
            method_pattern = rf'class\s+{class_name}.*?(?=class\s+\w+|$)'
            class_block = re.search(method_pattern, code, re.DOTALL)
            if class_block:
                methods = self._extract_python_functions(class_block.group())
                classes.append({
                    'name': class_name,
                    'methods': [m for m in methods if m['name'] != '__init__']
                })

        return classes

    def _generate_pytest(self, functions: List[Dict], classes: List[Dict]) -> str:
        """生成pytest测试"""
        lines = [
            '"""',
            '单元测试',
            'Generated by Leo Unit Test Generator',
            '"""',
            'import pytest',
            '',
            '# 导入被测模块',
            '# from module import function_name',
            ''
        ]

        # 函数测试
        for func in functions:
            name = func['name']
            params = func['params']

            lines.append(f'class Test{name.capitalize()}:')
            lines.append(f'    """测试 {name} 函数"""')
            lines.append('')

            # 正常情况测试
            lines.append(f'    def test_{name}_success(self):')
            lines.append(f'        """测试正常情况"""')
            if params:
                param_values = ', '.join(['None' for _ in params])
                lines.append(f'        # result = {name}({param_values})')
            else:
                lines.append(f'        # result = {name}()')
            lines.append('        # assert result is not None')
            lines.append('        pass')
            lines.append('')

            # 边界情况测试
            lines.append(f'    def test_{name}_edge_case(self):')
            lines.append(f'        """测试边界情况"""')
            lines.append('        pass')
            lines.append('')

            # 异常情况测试
            lines.append(f'    def test_{name}_error(self):')
            lines.append(f'        """测试异常情况"""')
            lines.append('        # with pytest.raises(ValueError):')
            lines.append(f'        #     {name}(invalid_input)')
            lines.append('        pass')
            lines.append('')

        # 类测试
        for cls in classes:
            class_name = cls['name']
            lines.append(f'class Test{class_name}:')
            lines.append(f'    """测试 {class_name} 类"""')
            lines.append('')

            lines.append('    @pytest.fixture')
            lines.append(f'    def instance(self):')
            lines.append(f'        """创建测试实例"""')
            lines.append(f'        # return {class_name}()')
            lines.append('        pass')
            lines.append('')

            for method in cls['methods']:
                method_name = method['name']
                lines.append(f'    def test_{method_name}(self, instance):')
                lines.append(f'        """测试 {method_name} 方法"""')
                lines.append(f'        # result = instance.{method_name}()')
                lines.append('        # assert result is not None')
                lines.append('        pass')
                lines.append('')

        return '\n'.join(lines)

    def _generate_unittest(self, functions: List[Dict], classes: List[Dict]) -> str:
        """生成unittest测试"""
        lines = [
            '"""',
            '单元测试 (unittest)',
            '"""',
            'import unittest',
            '',
            ''
        ]

        for func in functions:
            name = func['name']
            lines.append(f'class Test{name.capitalize()}(unittest.TestCase):')
            lines.append(f'    def test_{name}_success(self):')
            lines.append('        pass')
            lines.append('')

        lines.append("if __name__ == '__main__':")
        lines.append('    unittest.main()')

        return '\n'.join(lines)

    def _generate_conftest(self) -> str:
        """生成pytest conftest"""
        return '''"""
Pytest配置文件
"""
import pytest


@pytest.fixture
def sample_data():
    """示例数据fixture"""
    return {
        'id': 1,
        'name': 'test'
    }


@pytest.fixture
def mock_db(mocker):
    """Mock数据库"""
    return mocker.MagicMock()
'''

    def _generate_js_tests(self, source_code: str, framework: str) -> Dict[str, str]:
        """生成JavaScript测试"""
        functions = self._extract_js_functions(source_code)

        if framework == 'vitest':
            return {'test': self._generate_vitest(functions)}
        else:
            return {'test': self._generate_jest(functions)}

    def _extract_js_functions(self, code: str) -> List[Dict]:
        """提取JavaScript函数"""
        patterns = [
            r'function\s+(\w+)\s*\((.*?)\)',  # function name()
            r'const\s+(\w+)\s*=\s*(?:async\s*)?\((.*?)\)\s*=>',  # const name = () =>
            r'(\w+)\s*\((.*?)\)\s*{',  # method()
        ]

        functions = []
        for pattern in patterns:
            matches = re.findall(pattern, code)
            for match in matches:
                name, params = match
                if name not in ['if', 'for', 'while', 'switch']:
                    functions.append({
                        'name': name,
                        'params': [p.strip() for p in params.split(',') if p.strip()]
                    })

        return functions

    def _generate_vitest(self, functions: List[Dict]) -> str:
        """生成Vitest测试"""
        lines = [
            "import { describe, it, expect, vi } from 'vitest'",
            '',
            '// import { functionName } from "./module"',
            ''
        ]

        for func in functions:
            name = func['name']
            lines.append(f"describe('{name}', () => {{")
            lines.append(f"  it('should work correctly', () => {{")
            lines.append(f"    // const result = {name}()")
            lines.append(f"    // expect(result).toBeDefined()")
            lines.append(f"  }})")
            lines.append('')
            lines.append(f"  it('should handle edge cases', () => {{")
            lines.append(f"    // Test edge cases")
            lines.append(f"  }})")
            lines.append('})')
            lines.append('')

        return '\n'.join(lines)

    def _generate_jest(self, functions: List[Dict]) -> str:
        """生成Jest测试"""
        lines = [
            "// Jest tests",
            ''
        ]

        for func in functions:
            name = func['name']
            lines.append(f"describe('{name}', () => {{")
            lines.append(f"  test('should work', () => {{")
            lines.append(f"    expect(true).toBe(true)")
            lines.append(f"  }})")
            lines.append('})')
            lines.append('')

        return '\n'.join(lines)

    def save_files(self, module_name: str, results: Dict[str, str]) -> Dict[str, Path]:
        """保存生成的文件"""
        saved = {}
        tests_dir = self.output_dir / 'tests'
        tests_dir.mkdir(parents=True, exist_ok=True)

        ext = '.py' if self.language == 'python' else '.spec.ts'

        if 'test' in results:
            test_path = tests_dir / f'test_{module_name}{ext}'
            test_path.write_text(results['test'], encoding='utf-8')
            saved['test'] = test_path

        if 'conftest' in results:
            conftest_path = tests_dir / 'conftest.py'
            conftest_path.write_text(results['conftest'], encoding='utf-8')
            saved['conftest'] = conftest_path

        return saved


def main():
    """示例用法"""
    # Python示例
    python_code = '''
class UserService:
    def __init__(self, db):
        self.db = db

    def get_user(self, user_id: int) -> dict:
        return self.db.get(user_id)

    def create_user(self, name: str, email: str) -> dict:
        return self.db.create({'name': name, 'email': email})

def validate_email(email: str) -> bool:
    return '@' in email
'''

    generator = UnitTestGenerator(output_dir="./output", language="python")
    results = generator.generate(python_code, test_framework='pytest')
    saved = generator.save_files('user_service', results)

    print("生成完成！")
    for name, path in saved.items():
        print(f"  {name}: {path}")


if __name__ == '__main__':
    main()
